
<!DOCTYPE html>

<!--[if lt IE 7 ]> <html class="ie ie6 ie-lt10 ie-lt9 ie-lt8 ie-lt7 no-js" lang="en"> <![endif]-->
<!--[if IE 7 ]>    <html class="ie ie7 ie-lt10 ie-lt9 ie-lt8 no-js" lang="en"> <![endif]-->
<!--[if IE 8 ]>    <html class="ie ie8 ie-lt10 ie-lt9 no-js" lang="en"> <![endif]-->
<!--[if IE 9 ]>    <html class="ie ie9 ie-lt10 no-js" lang="en"> <![endif]-->
<!--[if gt IE 9]><!--><html class="no-js" lang="en"><!--<![endif]-->

<head>

	<meta charset="UTF-8">
	<meta content="text/html;charset=utf-8" http-equiv="Content-Type">
	<meta content="utf-8" http-equiv="encoding">

	<!--
		HTML5 Reset: https://github.com/murtaugh/HTML5-Reset
		Free to use
	-->

	<!-- Always force latest IE rendering engine (even in intranet) -->
	<meta http-equiv="X-UA-Compatible" content="IE=edge">

	<title>TVAJLAJT</title>
	<meta name="author" content="" />
	<meta name="description" content="" />

	<!-- Don't forget to set your site up: http://google.com/webmasters -->
	<meta name="google-site-verification" content="" />

	<!-- Who owns the content of this site? -->
	<meta name="" content="" />

	<!--  Mobile Viewport
	http://j.mp/mobileviewport & http://davidbcalhoun.com/2010/viewport-metatag
	device-width : Occupy full width of the screen in its current orientation
	initial-scale = 1.0 retains dimensions instead of zooming out if page height > device height
	maximum-scale = 1.0 retains dimensions instead of zooming in if page width < device width (wrong for most sites)
	-->
	<meta name="viewport" content="width=device-width, initial-scale=1">

	<link rel="shortcut icon" href="assets/media/favicon/favicon.ico" />
	<!-- <link rel="icon" type="image/svg+xml" href="assets/media/favicon/favicon.svg"> SVG file not in use, for practises unclear -->

	<!-- generics -->
	<link rel="icon" href="assets/media/favicon/favicon-32.png" sizes="32x32">
	<link rel="icon" href="assets/media/favicon/favicon-57.png" sizes="57x57">
	<link rel="icon" href="assets/media/favicon/favicon-76.png" sizes="76x76">
	<link rel="icon" href="assets/media/favicon/favicon-96.png" sizes="96x96">
	<link rel="icon" href="assets/media/favicon/favicon-128.png" sizes="128x128">
	<link rel="icon" href="assets/media/favicon/favicon-192.png" sizes="192x192">
	<link rel="icon" href="assets/media/favicon/favicon-228.png" sizes="228x228">

	<!-- Android -->
	<link rel="shortcut icon" sizes="196x196" href="assets/media/favicon/favicon-196.png">

	<!-- iOS -->
	<link rel="apple-touch-icon" href="assets/media/favicon/favicon-120.png" sizes="120x120">
	<link rel="apple-touch-icon" href="assets/media/favicon-152.png" sizes="152x152">
	<link rel="apple-touch-icon" href="assets/media/favicon-180.png" sizes="180x180">

	<!-- Windows 8 IE 10-->
	<meta name="msapplication-TileColor" content="#FFFFFF">
	<meta name="msapplication-TileImage" content="assets/media/favicon/favicon-144.png">

	<!-- Windows 8.1 + IE11 and above -->
	<meta name="msapplication-config" content="assets/media/favicon/browserconfig.xml" />

	<link rel="apple-touch-icon" sizes="76x76" href="assets/media/TouchIcons/apple-touch-icon-76x76-precomposed.png">
	<link rel="apple-touch-icon" sizes="114x114" href="assets/media/TouchIcons/apple-touch-icon-114x114-precomposed.png">
	<link rel="apple-touch-icon" sizes="120x120" href="assets/media/TouchIcons/apple-touch-icon-120x120-precomposed.png">
	<link rel="apple-touch-icon" sizes="144x144" href="assets/media/TouchIcons/apple-touch-icon-144x144-precomposed.png">
	<link rel="apple-touch-icon" sizes="152x152" href="assets/media/TouchIcons/apple-touch-icon-152x152-precomposed.png">
	<link rel="apple-touch-icon" sizes="180x180" href="assets/media/TouchIcons/apple-touch-icon-180x180-precomposed.png">

	<!-- concatenate and minify fr production -->
	<link rel="stylesheet" href="assets/css/style.css" />
	<link rel="stylesheet" href="assets/css/fonts.css" />

	<!-- Lea Verou's prefixfree (http://leaverou.github.io/prefixfree/), lets you use un-prefixed properties in your CSS files -->
	<script src="assets/js/libs/prefixfree.min.js"></script>

	<!-- This is a minimized, base version of Modernizr. (http://modernizr.com)
		  You will need to create new builds to get the detects you need. -->
	<script src="assets/js/libs/modernizr-3.2.0.base.js"></script>

	<script src="assets/js/libs/jquery-3.3.1.min.js"></script>

	<script language="JavaScript">
	    
	</script>

</head>

<body>

<div id="wrapper" onclick="closeMenu()">

	<div id="newGameWrapper" onclick="closeMenu()">
		<div class="newGameForm" onclick="noBubbling(event)">
					<form id="newGameForm" onsubmit="return submitNewGame(event);">
			<!-- No longer submitting via HTTP, using Socket.IO instead -->
				Flipped objectives:
				<br>
				<select name="flippedobjectives">
					<option value="0">0 flipped objectives</option>
					<option value="1">1 flipped objective</option>
					<option value="2">2 flipped objectives</option>
					<option value="3" selected>3 flipped objectives</option>
					<option value="4">4 flipped objectives</option>
					<option value="5">5 flipped objectives</option>
				</select>
				<br>
				<br>
				Settings:
				<br>
				<select name="startingcards">
					<option value="1">1 starting card</option>
					<option value="2">2 starting cards</option>
					<option value="3">3 starting cards</option>
					<option value="4">4 starting cards</option>
					<option value="5" selected>5 starting cards</option>
					<option value="6">6 starting cards</option>
				</select>
				<br>
				Use community objectives:
				<br>
				<input type="checkbox" class="checkbox" checked name="communitycards" value="true" onchange="updateCommunityCardsHidden(this)">
				<input type="hidden" name="communitycards_hidden" value="true">
				<br>
				<br>
				Players:
				<br>
				<input type="text" name="player1_name" placeholder="Player name (leave empty if not in play)" size="49">
				<br>
				<select name="player1_faction">
					<option value="none" disabled>Faction</option>
					<option disabled>──────────</option>
					<option value="arborec" selected>The Arborec</option>
					<option value="letnev">The Barony of Letnev</option>
					<option value="saar">The Clan of Saar</option>
					<option value="muaat">The Embers of Muaat</option>
					<option value="hacan">The Emirates of Hacan</option>
					<option value="sol">The Federation of Sol</option>
					<option value="creuss">The Ghosts of Creuss</option>
					<option value="lizix">The L1Z1X Mindnet</option>
					<option value="mentak">The Mentak Coalition</option>
					<option value="naalu">The Naalu Collective</option>
					<option value="nekro">The Nekro Virus</option>
					<option value="sardakk">The Sardakk N’orr</option>
					<option value="jolnar">The Universities of Jol-Nar</option>
					<option value="winnu">The Winnu</option>
					<option value="xxcha">The Xxcha Kingdom</option>
					<option value="yin">The Yin Brotherhood</option>
					<option value="yssaril">The Yssaril Tribes</option>
				</select>
				<select name="player1_color">
					<option value="none" disabled>Color</option>
					<option disabled>───</option>
					<option value="black">Black</option>
					<option value="blue">Blue</option>
					<option value="green" selected>Green</option>
					<option value="purple">Purple</option>
					<option value="red">Red</option>
					<option value="yellow">Yellow</option>
				</select>
				<br>
				<input type="text" name="player2_name" placeholder="Player name (leave empty if not in play)" size="49">
				<br>
				<select name="player2_faction">
					<option value="none" disabled>Faction</option>
					<option disabled>──────────</option>
					<option value="arborec">The Arborec</option>
					<option value="letnev">The Barony of Letnev</option>
					<option value="saar">The Clan of Saar</option>
					<option value="muaat">The Embers of Muaat</option>
					<option value="hacan">The Emirates of Hacan</option>
					<option value="sol">The Federation of Sol</option>
					<option value="creuss" selected>The Ghosts of Creuss</option>
					<option value="lizix">The L1Z1X Mindnet</option>
					<option value="mentak">The Mentak Coalition</option>
					<option value="naalu">The Naalu Collective</option>
					<option value="nekro">The Nekro Virus</option>
					<option value="sardakk">The Sardakk N’orr</option>
					<option value="jolnar">The Universities of Jol-Nar</option>
					<option value="winnu">The Winnu</option>
					<option value="xxcha">The Xxcha Kingdom</option>
					<option value="yin">The Yin Brotherhood</option>
					<option value="yssaril">The Yssaril Tribes</option>
				</select>
				<select name="player2_color">
					<option value="none" disabled>Color</option>
					<option disabled>───</option>
					<option value="black">Black</option>
					<option value="blue" selected>Blue</option>
					<option value="green">Green</option>
					<option value="purple">Purple</option>
					<option value="red">Red</option>
					<option value="yellow">Yellow</option>
				</select>
				<br>
				<input type="text" name="player3_name" placeholder="Player name (leave empty if not in play)" size="49">
				<br>
				<select name="player3_faction">
					<option value="none" disabled>Faction</option>
					<option disabled>──────────</option>
					<option value="arborec">The Arborec</option>
					<option value="letnev">The Barony of Letnev</option>
					<option value="saar">The Clan of Saar</option>
					<option value="muaat">The Embers of Muaat</option>
					<option value="hacan">The Emirates of Hacan</option>
					<option value="sol">The Federation of Sol</option>
					<option value="creuss">The Ghosts of Creuss</option>
					<option value="lizix" selected>The L1Z1X Mindnet</option>
					<option value="mentak">The Mentak Coalition</option>
					<option value="naalu">The Naalu Collective</option>
					<option value="nekro">The Nekro Virus</option>
					<option value="sardakk">The Sardakk N’orr</option>
					<option value="jolnar">The Universities of Jol-Nar</option>
					<option value="winnu">The Winnu</option>
					<option value="xxcha">The Xxcha Kingdom</option>
					<option value="yin">The Yin Brotherhood</option>
					<option value="yssaril">The Yssaril Tribes</option>
				</select>
				<select name="player3_color">
					<option value="none" disabled>Color</option>
					<option disabled>───</option>
					<option value="black" selected>Black</option>
					<option value="blue">Blue</option>
					<option value="green">Green</option>
					<option value="purple">Purple</option>
					<option value="red">Red</option>
					<option value="yellow">Yellow</option>
				</select>
				<br>
				<input type="text" name="player4_name" placeholder="Player name (leave empty if not in play)" size="49">
				<br>
				<select name="player4_faction">
					<option value="none" disabled>Faction</option>
					<option disabled>──────────</option>
					<option value="arborec">The Arborec</option>
					<option value="letnev">The Barony of Letnev</option>
					<option value="saar" selected>The Clan of Saar</option>
					<option value="muaat">The Embers of Muaat</option>
					<option value="hacan">The Emirates of Hacan</option>
					<option value="sol">The Federation of Sol</option>
					<option value="creuss">The Ghosts of Creuss</option>
					<option value="lizix">The L1Z1X Mindnet</option>
					<option value="mentak">The Mentak Coalition</option>
					<option value="naalu">The Naalu Collective</option>
					<option value="nekro">The Nekro Virus</option>
					<option value="sardakk">The Sardakk N’orr</option>
					<option value="jolnar">The Universities of Jol-Nar</option>
					<option value="winnu">The Winnu</option>
					<option value="xxcha">The Xxcha Kingdom</option>
					<option value="yin">The Yin Brotherhood</option>
					<option value="yssaril">The Yssaril Tribes</option>
				</select>
				<select name="player4_color">
					<option value="none" disabled>Color</option>
					<option disabled>───</option>
					<option value="black">Black</option>
					<option value="blue">Blue</option>
					<option value="green">Green</option>
					<option value="purple">Purple</option>
					<option value="red">Red</option>
					<option value="yellow" selected>Yellow</option>
				</select>
				<br>
				<input type="text" name="player5_name" placeholder="Player name (leave empty if not in play)" size="49">
				<br>
				<select name="player5_faction">
					<option value="none" disabled>Faction</option>
					<option disabled>──────────</option>
					<option value="arborec">The Arborec</option>
					<option value="letnev">The Barony of Letnev</option>
					<option value="saar">The Clan of Saar</option>
					<option value="muaat">The Embers of Muaat</option>
					<option value="hacan">The Emirates of Hacan</option>
					<option value="sol">The Federation of Sol</option>
					<option value="creuss">The Ghosts of Creuss</option>
					<option value="lizix">The L1Z1X Mindnet</option>
					<option value="mentak">The Mentak Coalition</option>
					<option value="naalu">The Naalu Collective</option>
					<option value="nekro">The Nekro Virus</option>
					<option value="sardakk">The Sardakk N’orr</option>
					<option value="jolnar">The Universities of Jol-Nar</option>
					<option value="winnu">The Winnu</option>
					<option value="xxcha">The Xxcha Kingdom</option>
					<option value="yin" selected>The Yin Brotherhood</option>
					<option value="yssaril">The Yssaril Tribes</option>
				</select>
				<select name="player5_color">
					<option value="none" disabled>Color</option>
					<option disabled>───</option>
					<option value="black">Black</option>
					<option value="blue">Blue</option>
					<option value="green">Green</option>
					<option value="purple" selected>Purple</option>
					<option value="red">Red</option>
					<option value="yellow">Yellow</option>
				</select>
				<br>
				<input type="text" name="player6_name" placeholder="Player name (leave empty if not in play)" size="49">
				<br>
				<select name="player6_faction">
					<option value="none" disabled>Faction</option>
					<option disabled>──────────</option>
					<option value="arborec">The Arborec</option>
					<option value="letnev">The Barony of Letnev</option>
					<option value="saar">The Clan of Saar</option>
					<option value="muaat" selected>The Embers of Muaat</option>
					<option value="hacan">The Emirates of Hacan</option>
					<option value="sol">The Federation of Sol</option>
					<option value="creuss">The Ghosts of Creuss</option>
					<option value="lizix">The L1Z1X Mindnet</option>
					<option value="mentak">The Mentak Coalition</option>
					<option value="naalu">The Naalu Collective</option>
					<option value="nekro">The Nekro Virus</option>
					<option value="sardakk">The Sardakk N’orr</option>
					<option value="jolnar">The Universities of Jol-Nar</option>
					<option value="winnu">The Winnu</option>
					<option value="xxcha">The Xxcha Kingdom</option>
					<option value="yin">The Yin Brotherhood</option>
					<option value="yssaril">The Yssaril Tribes</option>
				</select>
				<select name="player6_color">
					<option value="none" disabled>Color</option>
					<option disabled>───</option>
					<option value="black">Black</option>
					<option value="blue">Blue</option>
					<option value="green">Green</option>
					<option value="purple">Purple</option>
					<option value="red" selected>Red</option>
					<option value="yellow">Yellow</option>
				</select>
				<br>
				<br>
				<input type="submit" value="Start new game">
				<div class="babySpacer"></div>
			</form action="/action_page.php">
		</div>
	</div>
	<div id="editScoreWrapper" onclick="closeMenu()"></div>
	<div id="warnTop"></div><div id="warnBottom"></div><div id="warnLeft"></div><div id="warnRight"></div>
	<div id="bigletter" onclick="bigletterHide()"></div>
	<div id="addCardWrapper" onclick="closeMenu()">
		<div class="objectiveStyleItem" onclick="addCard(event, 1)">Stage 1</div>
		<div class="objectiveStyleItem" onclick="addCard(event, 2)">Stage 2</div>
	</div>
	<div id="adjustCardWrapper" onclick="closeMenu()">
		<div class="objectiveStyleItem" onclick="adjustCard(event, 'hide')">Hide</div>
		<div class="objectiveStyleItem" onclick="adjustCard(event, 'change')">Change</div>
		<div class="objectiveStyleItem" onclick="adjustCard(event, 'remove')">Remove</div>
	</div>
	<div id="changeVPWrapper">
		<div class="objectiveStyleItem" onclick="changeVP(event, '-')">-</div>
		<div class="objectiveStyleItem" onclick="changeVP(event, '+')">+</div>
	</div>
	<div id="changeCustodianWrapper" onclick="closeMenu()"></div>
	<div id="objectiveStyleWrapper" onclick="closeMenu()">
		<div class="objectiveStyleItem" onclick="chooseCard(event, 'random')">Random</div>
		<div class="objectiveStyleItem" onclick="chooseCard(event, 'list')">List</div>
	</div>
	<div id="objectiveMenuWrapper" onclick="closeMenu()">
		<div id="objectiveMenu">
			<div class="objectiveMenuTab" onclick="objectiveCategory(event, 'stage1')">Stage 1</div>
			<div class="objectiveMenuTab" onclick="objectiveCategory(event, 'stage2')">Stage 2</div>
			<div class="objectiveMenuTab" onclick="objectiveCategory(event, 'secret')">Secret</div>
			<div id="objectiveList"></div>
		</div>
	</div>
	<div id="sideMenuBg" onclick="closeMenu()"><div id="sideMenu">
		<div id="btnNew" class="sideMenuItem" onclick="buttonClick(event, this.id)"><img class="sideMenuItemIcon" src="assets/media/buttons/new.png"><div class="sideMenuItemText">New game</div></div>
		<div id="btnAddcard" class="sideMenuItem" onclick="buttonClick(event, this.id)"><img class="sideMenuItemIcon" src="assets/media/buttons/addcard.png"><div class="sideMenuItemText">Add card</div></div>
		<div id="btnAdjustcard" class="sideMenuItem" onclick="buttonClick(event, this.id)"><img class="sideMenuItemIcon" src="assets/media/buttons/edit.png"><div class="sideMenuItemText">Adjust card</div></div>
            <div id="btnReset" class="sideMenuItem" onclick="buttonClick(event, this.id)"><img class="sideMenuItemIcon" src="assets/media/buttons/reset.png"><div class="sideMenuItemText">Reset</div></div>
		<div id="btnSuperuser" class="sideMenuItem" onclick="buttonClick(event, this.id)"></div>
	</div></div>
	
	<div id="header">
		<div id="sideMenuButton" onclick="showMenu(event)">
			<img src="assets/media/buttons/menu.png">
		</div>
		<div id="gameTimer" onclick="togglePause()" title="Click to pause/resume game">
			<span id="timerDisplay">00:00:00</span>
		</div>
		<div id="logo">
			<img src="assets/media/tvajlajt.png">
		</div>
		<div id="sideMenuRefresh" title="Auto-refresh" onclick="buttonClick(event, this.id)"></div>
	</div>

	<div id="scoreboard">
		<!-- Top scoreboard -->
	</div>
    <div class="obj" id="objectives1">
        <!-- Objectives Stage 1 -->
    </div>
    <!-- <div class="sides right">.</div> -->
	<div class="obj" id="objectives2">
		<!-- Objectives Stage 2 -->
	</div>

</div>

<script src="assets/js/functions.js"></script>
<script src="/socket.io/socket.io.js"></script>

<script>

	// Debug logging for application startup
	console.log('🚀 APP: Tvajlajt application starting...');
	console.log('🌐 APP: User agent:', navigator.userAgent);
	console.log('📍 APP: Current URL:', window.location.href);
	console.log('🔧 APP: jQuery version:', $.fn.jquery);
	
	// Security: HTML escaping function to prevent XSS
	function escapeHtml(unsafe) {
		if (typeof unsafe !== 'string') return unsafe;
		return unsafe
			.replace(/&/g, "&amp;")
			.replace(/</g, "&lt;")
			.replace(/>/g, "&gt;")
			.replace(/"/g, "&quot;")
			.replace(/'/g, "&#039;");
	}
	console.log('🛡️ APP: HTML escaping function initialized');

	var serverUrl = "http://localhost:3000";
	var superuser;
	var autorefresh;
	var refreshCounter = 30;
	
	// Initialize Socket.IO connection
	console.log('🔌 CLIENT: Initializing Socket.IO connection...');
	var socket = io();
	
	// Socket.IO event logging
	socket.on('connect', function() {
		console.log('✅ CLIENT: Connected to server, socket ID:', socket.id);
	});
	
	socket.on('disconnect', function(reason) {
		console.error('❌ CLIENT: Disconnected from server, reason:', reason);
	});
	
	socket.on('connect_error', function(error) {
		console.error('❌ CLIENT: Connection error:', error);
	});
	
	socket.on('error', function(error) {
		console.error('❌ CLIENT: Socket error:', error);
	});
	
	// Listen for interface refresh events from other clients
	socket.on('interface_refresh', function(data) {
		console.log('📡 CLIENT: Received interface refresh event from another client');
		refreshGameData();
	});
	
	// Listen for any update events from the server
	socket.on('update', function(data) {
		console.log('📡 CLIENT: Received update event from server:', data);
		
		// Store the card ID to show in bigletter after refresh
		if (data && data.length >= 2) {
			var cardID = data[1]; // The card ID that was just assigned
			console.log('🎯 CLIENT: Card flipped, will show bigletter for card:', cardID);
			window.lastFlippedCardID = cardID; // Store for later use
		}
		
		// Refresh the interface when server sends updates
		setTimeout(refreshGameData, 500); // Small delay to ensure server has updated data.json
	});
	
	// Listen for new game events
	socket.on('newgame', function(data) {
		console.log('📡 CLIENT: Received newgame event from server');
		// Refresh the interface after new game is created
		setTimeout(refreshGameData, 1000); // Longer delay for new game setup
	});
	
	// Listen for token scoring events
	socket.on('token', function(data) {
		console.log('📡 CLIENT: Received token event from server');
		setTimeout(refreshGameData, 500);
	});
	
	// Listen for card addition events
	socket.on('addCard', function(data) {
		console.log('📡 CLIENT: Received addCard event from server');
		setTimeout(refreshGameData, 500);
	});
	
	// Listen for card adjustment events
	socket.on('adjustRemove', function(data) {
		console.log('📡 CLIENT: Received adjustRemove event from server');
		setTimeout(refreshGameData, 500);
	});
	
	socket.on('adjustHide', function(data) {
		console.log('📡 CLIENT: Received adjustHide event from server');
		setTimeout(refreshGameData, 500);
	});
	
	// Listen for score editing events
	socket.on('editscore', function(data) {
		console.log('📡 CLIENT: Received editscore event from server');
		setTimeout(refreshGameData, 500);
	});
	
	// Listen for VP change events
	socket.on('changeVP', function(data) {
		console.log('📡 CLIENT: Received changeVP event from server');
		setTimeout(refreshGameData, 500);
	});
	
	// Listen for reset events
	socket.on('reset', function(data) {
		console.log('📡 CLIENT: Received reset event from server');
		// Clear scoreboard immediately
		var scoreboardDiv = document.getElementById("scoreboard");
		if (scoreboardDiv) {
			scoreboardDiv.innerHTML = "";
		}
		setTimeout(refreshGameData, 1000); // Longer delay for reset
	});
	var autorefreshInterval;

	var stagePressed;
	var cardPressed;
	var tokenPressed;
	var vpPressed;

	var clickMode = null;

	var allObjectives = [];
	var stageOneObjectives = [];
	var stageTwoObjectives = [];
	var secretObjectives = [];
	var objectivesOnBoard = {"stage1":[], "stage2":[]};
	var communityObjectives;

	var allPlayers = [];
	var allScores = [];
	
	// Track menu states
	var additionalScoresMenuOpen = false;
	
	// Timer variables
	var gameTimer = null;
	var isPaused = false;

	// Function to create the scoreboard
	function createScoreboard(players, playerScores) {
		console.log('📊 CLIENT: Creating scoreboard...');
		var scoreboardDiv = document.getElementById("scoreboard");
		if (scoreboardDiv) {
			scoreboardDiv.innerHTML = "";
			
			// Add click handler to the scoreboard div
			scoreboardDiv.onclick = function() {
				showScoreboardDetails(players, playerScores);
			};
			
			for (var i = 0; i < players.length; i++) { // Iterate players
				var el_ScoreToken = document.createElement("div");
				el_ScoreToken.className = 'scoretile';
				el_ScoreToken.title = decodeURIComponent(players[i].player);
				el_ScoreToken.innerHTML = '<img src="assets/media/factions/' + players[i].faction + '.png">' + playerScores[i];
				scoreboardDiv.appendChild(el_ScoreToken);
			}
			console.log('✅ CLIENT: Scoreboard created with', players.length, 'players');
		} else {
			console.error('❌ CLIENT: Scoreboard div not found!');
		}
	}
	
	// Function to show scoreboard details in bigletter
	function showScoreboardDetails(players, playerScores) {
		console.log('📊 CLIENT: Showing scoreboard details...');
		var html = '<div class="blTitle">Player Scores</div>';
		
		for (var i = 0; i < players.length; i++) {
			html += '<div class="blText" style="margin: 2vw 0;">';
			html += '<img src="assets/media/factions/' + players[i].faction + '.png" style="width: 4vw; height: 4vw; margin-right: 2vw;">';
			html += decodeURIComponent(players[i].player) + ': ' + playerScores[i] + ' VP';
			html += '</div>';
		}
		
		$('#bigletter').html(html);
		document.getElementById('bigletter').style.visibility = 'visible';
	}
	
	// Function to format time as HH:MM:SS
	function formatTime(seconds) {
		var hours = Math.floor(seconds / 3600);
		var minutes = Math.floor((seconds % 3600) / 60);
		var secs = seconds % 60;
		return (hours < 10 ? '0' : '') + hours + ':' + (minutes < 10 ? '0' : '') + minutes + ':' + (secs < 10 ? '0' : '') + secs;
	}
	
	// Function to update timer display
	function updateTimer() {
		if (!gameTimer) return;
		
		$.getJSON("data.json?v=" + Date.now(), function(data) {
			if (data && data[3] && data[3].timeStart) {
				var currentTime = Date.now();
				var startTime = data[3].timeStart;
				var pauseTime = data[3].timePause || 0;
				
				var elapsedSeconds = Math.floor((currentTime - startTime) / 1000) - pauseTime;
				if (elapsedSeconds < 0) elapsedSeconds = 0;
				
				document.getElementById('timerDisplay').textContent = formatTime(elapsedSeconds);
			}
		});
	}
	
	// Function to toggle pause
	function togglePause() {
		if (isPaused) {
			// Resume game
			isPaused = false;
			if (socket && socket.connected) {
				socket.emit('pauseCounter', false);
				console.log('▶️ CLIENT: Game resumed');
			}
		} else {
			// Pause game
			isPaused = true;
			if (socket && socket.connected) {
				socket.emit('pauseCounter', true);
				console.log('⏸️ CLIENT: Game paused');
			}
			
			// Show pause message in bigletter
			var html = '<div class="blTitle">Game Paused</div>';
			$('#bigletter').html(html);
			document.getElementById('bigletter').style.visibility = 'visible';
		}
	}
	
	// Function to update community cards hidden input
	function updateCommunityCardsHidden(checkbox) {
		var hiddenInput = document.querySelector('input[name="communitycards_hidden"]');
		hiddenInput.value = checkbox.checked ? 'true' : 'false';
		console.log('🔍 CLIENT: Community cards checkbox changed to:', checkbox.checked);
	}
	
	// Function to show a card in the bigletter
	function showCardInBigletter(cardID) {
		console.log('🎯 CLIENT: Showing card in bigletter:', cardID);
		var cardInfo = getCardInfo(cardID);
		
		if (cardInfo) {
			var cardPhase = cardInfo.phase;
			var phaseColor = "";
			if (cardPhase == "Action Phase") phaseColor = "red";
			
			var html = '<div class="blPlayers"></div>' +
						'<div class="blTitle">' + cardInfo.name + '</div>' +
						'<div class="blText">' + cardInfo.text + '</div>' +
						'<div class="blPhaseAndPoints">' +
							'<div class="blPhase ' + phaseColor + '">' + cardPhase.substring(0, cardPhase.indexOf(" ")) + '</div>' +
							'<div class="blPoint">' + cardInfo.points + '</div>' +
							'<div class="blPhase ' + phaseColor + '">' + cardPhase.substring(cardPhase.indexOf(" ") + 1, cardPhase.length) + '</div>' +
						'</div>';
			
			console.log('🎯 CLIENT: Bigletter HTML:', html);
			$('#bigletter').html(html);
			document.getElementById('bigletter').style.visibility = 'visible';
			console.log('🎯 CLIENT: Bigletter should now be visible');
			
			// Set pauseCounter to false when bigletter is shown
			if (socket && socket.connected) {
				socket.emit('pauseCounter', false);
				console.log('⏸️ CLIENT: Pause counter set to false');
			}
		} else {
			console.error('❌ CLIENT: Card info not found for bigletter:', cardID);
		}
	}
	
	// Function to calculate scores from objectives
	function calculateScoresFromObjectives(data, playerScores) {
		console.log('📊 CLIENT: Calculating scores from objectives...');
		
		// Reset scores
		for (var i = 0; i < playerScores.length; i++) {
			playerScores[i] = 0;
		}
		
		// Calculate from Stage 1 objectives
		if (data[0] && data[0].cards) {
			for (var i = 0; i < data[0].cards.length; i++) {
				var cardID = data[0].cards[i].id;
				if (cardID != null) {
					var cardInfo = getCardInfo(cardID);
					if (cardInfo) {
						var cardPoints = parseInt(cardInfo.points);
						for (var j = 0; j < data[0].cards[i].scores.length; j++) {
							if (data[0].cards[i].scores[j].scored && j < playerScores.length) {
								playerScores[j] += cardPoints;
								console.log('📊 CLIENT: Player', j, 'scored', cardPoints, 'VP from Stage 1 card', cardID);
							}
						}
					}
				}
			}
		}
		
		// Calculate from Stage 2 objectives
		if (data[1] && data[1].cards) {
			for (var i = 0; i < data[1].cards.length; i++) {
				var cardID = data[1].cards[i].id;
				if (cardID != null) {
					var cardInfo = getCardInfo(cardID);
					if (cardInfo) {
						var cardPoints = parseInt(cardInfo.points);
						for (var j = 0; j < data[1].cards[i].scores.length; j++) {
							if (data[1].cards[i].scores[j].scored && j < playerScores.length) {
								playerScores[j] += cardPoints;
								console.log('📊 CLIENT: Player', j, 'scored', cardPoints, 'VP from Stage 2 card', cardID);
							}
						}
					}
				}
			}
		}
		
		// Add additional VPs
		for (var i = 0; i < data[2].players.length; i++) {
			if (data[2].players[i].faction != null && i < playerScores.length) {
				var additionalVP = data[2].players[i].vp_custodian + data[2].players[i].vp_imperial + data[2].players[i].vp_secrets + data[2].players[i].vp_riders + data[2].players[i].vp_other;
				playerScores[i] += additionalVP;
				if (additionalVP > 0) {
					console.log('📊 CLIENT: Player', i, 'has', additionalVP, 'additional VP');
				}
			}
		}
		
		console.log('📊 CLIENT: Final player scores:', playerScores);
	}

    window.onload = function() {
		console.log('🚀 CLIENT: Window loaded, initializing application...');

		// Superuser check with cookies
		console.log('👤 CLIENT: Checking superuser status...');
		var superuserCookie = localStorage.getItem('superuser');
		if (superuserCookie == null) {
			localStorage.setItem('superuser', false);
			superuser = false;
		} else {
			superuser = (superuserCookie == "true"); // Set string of boolean to actual boolean
		}
		var superuserHtml = (superuser) ? "y" : (!superuser) ? "n" : "";
		document.getElementById("btnSuperuser").innerHTML = '<img class="sideMenuItemIcon" src="assets/media/buttons/superuser_' + superuserHtml + '.png"><div class="sideMenuItemText">Superuser</div>';

		// Check if refresher
		console.log('🔄 CLIENT: Checking auto-refresh settings...');
		var refresherCookies = localStorage.getItem('autorefresh');
		console.log('🔄 CLIENT: Auto-refresh cookie value:', refresherCookies);
		
		if (refresherCookies == null) {
			localStorage.setItem('autorefresh', false);
			autorefresh = false;
			console.log('🔄 CLIENT: No auto-refresh cookie found, setting to false');
		} else {
			autorefresh = (refresherCookies == "true"); // Set string of boolean to actual boolean
			console.log('🔄 CLIENT: Auto-refresh enabled:', autorefresh);
			if (autorefresh) $("sideMenuRefresh").addClass("active");
		}

		// Load game data and initialize interface
		console.log('📊 CLIENT: Generating cache buster for data.json...');
		var jsonBuster = "?v=" + Math.floor((Math.random() * 9) + 1) + Math.floor((Math.random() * 9) + 1) + "." + Math.floor((Math.random() * 9) + 1) + Math.floor((Math.random() * 9) + 1) + "." + Math.floor((Math.random() * 9) + 1) + Math.floor((Math.random() * 9) + 1);
		console.log('🔍 CLIENT: Data cache buster:', jsonBuster);
		
		console.log('📊 CLIENT: Loading data.json...');
		$.getJSON( "data.json" + jsonBuster, function(data) {
		console.log("✅ CLIENT: Data.json loaded successfully!");
		console.log("📊 CLIENT: Game data structure:", data);

		// Check if community objectives are in play
		console.log('🎮 CLIENT: Checking for community cards setting...');
		
		// Clear existing objectives arrays first
		allObjectives = [];
		stageOneObjectives = [];
		stageTwoObjectives = [];
		secretObjectives = [];
		
		// Load main database first
		$.getJSON("database.json" + jsonBuster, function(mainObjectives) {
			console.log('✅ CLIENT: Main database loaded successfully!');
			
			// Load main objectives
			for (var i = 0; i < mainObjectives[0].stage1.length; i++) {
				allObjectives.push(mainObjectives[0].stage1[i]);
				stageOneObjectives.push(mainObjectives[0].stage1[i]);
			}
			for (var i = 0; i < mainObjectives[0].stage2.length; i++) {
				allObjectives.push(mainObjectives[0].stage2[i]);
				stageTwoObjectives.push(mainObjectives[0].stage2[i]);
			}
			
			if (data[3].communitycards) {
				console.log('✅ CLIENT: Community cards enabled, loading community database...');
				// Load community cards synchronously to ensure they're available before creating objectives
				$.getJSON("database_community.json" + jsonBuster, function(communityObjectives) {
					console.log('✅ CLIENT: Community database loaded successfully!');
					for (var i = 0; i < communityObjectives[0].stage1.length; i++) {
						allObjectives.push(communityObjectives[0].stage1[i]);
						stageOneObjectives.push(communityObjectives[0].stage1[i]);
					}
					for (var i = 0; i < communityObjectives[0].stage2.length; i++) {
						allObjectives.push(communityObjectives[0].stage2[i]);
						stageTwoObjectives.push(communityObjectives[0].stage2[i]);
					}
					for (var i = 0; i < communityObjectives[0].secret.length; i++) {
						allObjectives.push(communityObjectives[0].secret[i]);
						secretObjectives.push(communityObjectives[0].secret[i]);
					}
					console.log('📊 CLIENT: Total objectives loaded:', allObjectives.length);
					console.log('📊 CLIENT: Stage 1 objectives:', stageOneObjectives.length);
					console.log('📊 CLIENT: Stage 2 objectives:', stageTwoObjectives.length);
					
					// Now create the objectives after all cards are loaded
					createGameInterface(data);
				}).fail(function(jqXHR, textStatus, errorThrown) {
					console.error('❌ CLIENT: Failed to load community database:', errorThrown);
					// Continue without community cards
					createGameInterface(data);
				});
			} else {
				console.log('ℹ️ CLIENT: Community cards disabled');
				console.log('📊 CLIENT: Total objectives loaded:', allObjectives.length);
				console.log('📊 CLIENT: Stage 1 objectives:', stageOneObjectives.length);
				console.log('📊 CLIENT: Stage 2 objectives:', stageTwoObjectives.length);
				// Create objectives immediately if no community cards
				createGameInterface(data);
			}
		}).fail(function(jqXHR, textStatus, errorThrown) {
			console.error('❌ CLIENT: Failed to load main database:', errorThrown);
			createGameInterface(data);
		});
		
		// Function to create the game interface after all cards are loaded
		function createGameInterface(data) {
			console.log('🎮 CLIENT: Creating game interface...');
			
			// Process players data
			var players = [];
			var playerScores = [];
			for (var i = 0; i < data[2].players.length; i++) {
				if (data[2].players[i].faction != null) {
					var playah = data[2].players[i];
					allPlayers.push(playah);
					allScores.push(0);
					players.push(playah);
					playerScores.push(0); // Initialize to 0, will be calculated from objectives
				}
			};
			
			// Calculate scores from objectives
			calculateScoresFromObjectives(data, playerScores);
			
			// Create elements for Stage 1
			var objectives1HTML = createObjectives(1, data, players, playerScores);
			// Create elements for Stage 2
			var objectives2HTML = createObjectives(2, data, players, playerScores);
			
			// Create scoreboard
			createScoreboard(players, playerScores);
	
			// Check if the objectives data is valid (but don't reload immediately)
			console.log('🔍 CLIENT: Checking objectives data validity...');
			console.log('📊 CLIENT: data defined:', data !== undefined);
			console.log('📊 CLIENT: data[0].cards.length:', data ? data[0].cards.length : 'N/A');
			console.log('📊 CLIENT: objectives1 element exists:', document.getElementById("objectives1") !== null);
			console.log('📊 CLIENT: objectives1 childElementCount:', document.getElementById("objectives1") ? document.getElementById("objectives1").childElementCount : 'N/A');
			
			if (data == undefined) {
				console.error('❌ CLIENT: Game data is undefined! This is a serious error.');
				return; // Exit function instead of reloading
			}
			
			// Only reload if there's a major data inconsistency that can't be fixed
			var objectives1Element = document.getElementById("objectives1");
			if (!objectives1Element) {
				console.error('❌ CLIENT: objectives1 element not found in DOM!');
				// This might be a timing issue, try again after a delay
				setTimeout(function() {
					refreshGameData();
				}, 1000);
				return;
			}
			
			console.log('✅ CLIENT: Objectives data looks valid, continuing with interface creation...');

			// If there's players in game, create Mecatol/Secrets/Riders/Prommisory elements
			if (players.length != 0) {
				var el_AddWrapperDiv = document.createElement("div");
					el_AddWrapperDiv.id = "additionalElementsWrapper";
					el_AddWrapperDiv.onclick = function() {
						$("#additionalElementsWrapper").toggleClass("open");
						$("#additionalElementsArrowLeft").toggleClass("open");
						$("#additionalElementsArrowRight").toggleClass("open");
						
						// Track menu state
						additionalScoresMenuOpen = $("#additionalElementsWrapper").hasClass("open");
						console.log('📊 CLIENT: Additional Scores menu state:', additionalScoresMenuOpen ? 'open' : 'closed');
					}
				document.getElementById("wrapper").appendChild(el_AddWrapperDiv);
					var el_AddTextArrowWrapperDiv = document.createElement("div");
						el_AddTextArrowWrapperDiv.className = "additionalElementsTextArrowWrapper";
						el_AddWrapperDiv.appendChild(el_AddTextArrowWrapperDiv);
						var el_AddArrowDiv = document.createElement("div");
							el_AddArrowDiv.id = "additionalElementsArrowLeft";
							el_AddArrowDiv.innerHTML = "<img src='assets/media/arrow_white.png'>";
						el_AddTextArrowWrapperDiv.appendChild(el_AddArrowDiv);
						var el_AddButtonDiv = document.createElement("div");
							el_AddButtonDiv.className = "additionalElementsText";
							el_AddButtonDiv.innerHTML = "Additional Scores";
						el_AddTextArrowWrapperDiv.appendChild(el_AddButtonDiv);
						var el_AddArrowDiv = document.createElement("div");
							el_AddArrowDiv.id = "additionalElementsArrowRight";
							el_AddArrowDiv.innerHTML = "<img src='assets/media/arrow_white.png'>";
						el_AddTextArrowWrapperDiv.appendChild(el_AddArrowDiv);
					var el_AddDiv = document.createElement("div");
						el_AddDiv.id = "additionalElements";
					el_AddWrapperDiv.appendChild(el_AddDiv);
				createAdditionalPoints(players);
			}
		}

			function createObjectives(stage, data, players, playerScores) {
				var divHTML = "";
				var stageIndex = stage-1;
				stagePressed = stage;
				// Count card number and assign class name
				var objectivesCount = data[stageIndex].cards.length;

				var activeCardIndex = 0;
				for (var i = 0; i < objectivesCount; i++) { // Iterate objectives
					var cardID = data[stageIndex].cards[i].id;
					if (stage == 1) {
						objectivesOnBoard.stage1.push(data[stageIndex].cards[i]);
					} else {
						objectivesOnBoard.stage2.push(data[stageIndex].cards[i]);
					}
					if (cardID != null) { // If active

						// Get card and create div
						for (var k = 0; k < allObjectives.length; k++) {
							if (cardID == allObjectives[k].id) {

								var cardName = allObjectives[k].name;
								var cardText = allObjectives[k].text;
								var cardPoints = allObjectives[k].points;
								var cardStage = allObjectives[k].stage;
								var cardPhase = allObjectives[k].phase;
								var phaseColor = "";
								if (cardPhase == "Action Phase") phaseColor = "red";

								// Create elements
								var objectiveDiv = document.getElementById("objectives" + stage);
								
								var el_TokensAndCard = document.createElement("div");
									el_TokensAndCard.className = "tokensAndCard";
								objectiveDiv.appendChild(el_TokensAndCard);

								var el_Objective = document.createElement("div");
									el_Objective.className = 'objContainer';
									el_Objective.id = i;
									el_Objective.innerHTML = "<img src='assets/media/objectivecard_bg_" + cardStage + ".png'>";
								el_TokensAndCard.appendChild(el_Objective);

								var el_ObjectiveText = document.createElement("div");
									el_ObjectiveText.className = 'objCard';
									el_ObjectiveText.id = cardID;
									el_ObjectiveText.innerHTML = "<h2>" + escapeHtml(cardName) + "</h2><p>" + escapeHtml(cardText) + "</p><h3>" + escapeHtml(cardPoints) + "</h3><p style='margin-top:-1.5vw' class='" + escapeHtml(phaseColor) + "'>" + escapeHtml(cardPhase) + "</p></div>";
									el_ObjectiveText.onclick = function() {
										var cardPressedIndex = parseInt(this.parentNode.id);
										stagePressed = this.parentNode.parentNode.parentNode.id;
										stagePressed = stagePressed.substring(stagePressed.length - 1, stagePressed.length);
										
										// Always set cardPressed to the card slot identifier for consistency
										cardPressed = "stage" + stagePressed + "_" + cardPressedIndex;
										
										if (clickMode != null) {
											if (clickMode == "hide" || clickMode == "remove") {
												if (confirm("Are you sure you want to " + clickMode + " this card?\nThe points will be reset for this card.")) {
													// Direct Socket.IO emission for card adjustment
													var adjustData = [clickMode, stagePressed, this.id, cardPressedIndex];
													console.log('📡 CLIENT: Emitting card adjustment:', adjustData);
													socket.emit('adjust' + clickMode.charAt(0).toUpperCase() + clickMode.slice(1), adjustData);
												}
											} else {
												document.getElementById('objectiveStyleWrapper').style.visibility = 'visible';
												event.stopPropagation();
											}
										} else {
											console.log('🎯 CLIENT: Card clicked - showing bigletter');
											var cardPressedStage = this.parentNode.parentNode.parentNode.id;
												cardPressedStage = parseInt(cardPressedStage.substring(cardPressedStage.length - 1, cardPressedStage.length));
											var blTokensHtml = "";
											
											if (cardPressedStage == 1) {
												var scoreArr = objectivesOnBoard.stage1[cardPressedIndex].scores;
											} else {
												var scoreArr = objectivesOnBoard.stage2[cardPressedIndex].scores;
											}
											for (var j = 0; j < scoreArr.length; j++) {
												if (scoreArr[j].scored) blTokensHtml = blTokensHtml + '<img src="assets/media/factions/' + players[j].faction + '.png">';
											}
											var cardObjDatabase = getCardInfo(this.id);
											console.log('🎯 CLIENT: Card object database:', cardObjDatabase);
											
											if (cardObjDatabase) {
												var cardPhase = cardObjDatabase.phase;
												var phaseColor = "";
												if (cardPhase == "Action Phase") phaseColor = "red";
												var html = 	'<div class="blPlayers">' + blTokensHtml + '</div>'+
															'<div class="blTitle">' + cardObjDatabase.name + '</div>'+
															'<div class="blText">' + cardObjDatabase.text + '</div>'+
															'<div class="blPhaseAndPoints">'+
																'<div class="blPhase ' + phaseColor + '">' + cardPhase.substring(0, cardPhase.indexOf(" ")) + '</div>'+
																'<div class="blPoint">' + cardObjDatabase.points + '</div>'+
																'<div class="blPhase ' + phaseColor + '">' + cardPhase.substring(cardPhase.indexOf(" ") + 1, cardPhase.length) + '</div>'+
															'</div>';
												console.log('🎯 CLIENT: Bigletter HTML:', html);
												$('#bigletter').html(html);
												document.getElementById('bigletter').style.visibility = 'visible';
												console.log('🎯 CLIENT: Bigletter should now be visible');
											} else {
												console.error('❌ CLIENT: Card object database is null/undefined');
											}
										}
									};
								el_Objective.appendChild(el_ObjectiveText);

								var el_TokensWrapper = document.createElement("div");
									el_TokensWrapper.className = "objTokensWrapper";
									el_TokensWrapper.id = activeCardIndex;

								var tokensHTML = "";
								for (var j = 0; j < players.length; j++) {
									var scoredClass = "";
									if (data[stageIndex].cards[i].scores[j].scored) {
										scoredClass = " scored";
									}

									var el_Tokens = document.createElement("div");
										el_Tokens.className = "objTokens" + scoredClass;
										el_Tokens.title = decodeURIComponent(players[j].player);
										el_Tokens.id = j;
										el_Tokens.innerHTML = '<img src="assets/media/factions/' + players[j].faction + '.png">';
																			el_Tokens.onclick = function() {
										if (superuser) {
											tokenPressed = this.id;
											// Direct Socket.IO emission for token scoring
											var tokenData = [stageIndex, this.parentNode.id, tokenPressed];
											console.log('📡 CLIENT: Emitting token scoring:', tokenData);
											socket.emit('token', tokenData);
										} else {
											notSuperuser();
										}
									}
										el_TokensWrapper.appendChild(el_Tokens);
								}
								
								el_TokensAndCard.appendChild(el_TokensWrapper);

							}
						}
						
						activeCardIndex++;

					} else {
						var tokensHTML = "";
						for (var j = 0; j < players.length; j++) {
							if (players[j].faction == null) {
								var token = "empty"
							} else {
								var token = players[j].faction;
							}
							tokensHTML = tokensHTML + '<div class="objTokens" title="' + decodeURIComponent(players[j].player) + '"><img src="assets/media/factions/' + token + '.png"></div>';
						}
						
						// Create elements
						var objectiveDiv = document.getElementById("objectives" + stage);

						var el_TokensAndCard = document.createElement("div");
							el_TokensAndCard.className = "tokensAndCard";
							el_TokensAndCard.id = i;
						objectiveDiv.appendChild(el_TokensAndCard);

						var el_Objective = document.createElement("div");
							el_Objective.className = 'objContainer';
							el_Objective.innerHTML = "<img src='assets/media/backside_stage" + stage + ".png'>";
							el_Objective.id = "stage" + stage + "_" + i;
							el_Objective.onclick = function(event) {
								if (superuser) {
									cardPressed = this.id;
									stagePressed = this.parentNode.parentNode.id;
									stagePressed = stagePressed.substring(stagePressed.length - 1, stagePressed.length);
									var cardPressedIndex = parseInt(this.parentNode.id);
																	if (clickMode == "remove") {
									if (confirm("Are you sure you want to remove this card?")) {
										// Direct Socket.IO emission for card removal
										var adjustData = [clickMode, stagePressed, cardPressed, cardPressedIndex];
										console.log('📡 CLIENT: Emitting card removal:', adjustData);
										socket.emit('adjustRemove', adjustData);
									}
								} else {
										document.getElementById('objectiveStyleWrapper').style.visibility = 'visible';
										event.stopPropagation();
									}
								} else {
									notSuperuser();
								}
							};
						el_TokensAndCard.appendChild(el_Objective);

						var el_TokensWrapper = document.createElement("div");
							el_TokensWrapper.className = "objTokensWrapper";
							el_TokensWrapper.innerHTML = tokensHTML;
						el_TokensAndCard.appendChild(el_TokensWrapper);

					}
					activeCardIndex++;
				}
			}

			function createAdditionalPoints(players) {

				var addEldiv = document.getElementById("additionalElements");

				// Mecatol VP
				var custodianHtml = "";
				for (var i = 0; i < players.length; i++) { // Iterate players
					if (players[i].vp_custodian) custodianHtml = '<img src="assets/media/factions/' + players[i].faction + '.png">';
				}
				var el_MecatolWrapper = document.createElement("div");
					el_MecatolWrapper.id = "mecatolScoreWrapper";
					el_MecatolWrapper.style = "display: inline-block; vertical-align: top;"

					var el_Mecatol = document.createElement("div");
						el_Mecatol.title = "Custodian Token VP";
						el_Mecatol.id = "mecatolScore";
						el_Mecatol.innerHTML = custodianHtml;
						el_Mecatol.onclick = function(event) {
							if (superuser) {
								var playerID = this.id.substring(this.id.length - 1, this.id.length);
								var category = this.id.substring(0, this.id.length - 2);

								var wrapper = document.getElementById('changeCustodianWrapper');
									wrapper.innerHTML = "Custodian Victory Point<br><br>";
								for (var i = 0; i < players.length; i++) { // Iterate players
									var el_Token = document.createElement("div");
										el_Token.className = 'custodianPick';
										el_Token.title = decodeURIComponent(players[i].player);
										el_Token.id = "custodian_" + i;
										el_Token.innerHTML = '<img src="assets/media/factions/' + players[i].faction + '.png">';
																			el_Token.onclick = function(event) {
										var playerID = this.id.substring(this.id.length - 1, this.id.length);
										vpPressed = { "player": playerID, "category": "custodian" };
										// Direct Socket.IO emission for custodian VP change
										var vpData = [playerID, "custodian"];
										console.log('📡 CLIENT: Emitting custodian VP change for player:', playerID);
										socket.emit('changeVP', vpData);
										// Close the custodian menu after selection
										document.getElementById('changeCustodianWrapper').style.visibility = 'hidden';
										noBubbling(event);
									}
									wrapper.appendChild(el_Token);
								}
								document.getElementById('changeCustodianWrapper').style.visibility = 'visible';
								noBubbling(event);
							} else {
								notSuperuser();
							}
						}
					el_MecatolWrapper.appendChild(el_Mecatol);
				addEldiv.appendChild(el_MecatolWrapper);

				// Imperial VP
				createAddDiv("Imperial VP", '<img src="assets/media/imperial.png">', "imperial");
				// Secrets VP
				createAddDiv("Secrets VP", '<img src="assets/media/backside_secret.png">', "secrets");
				// Rider VP
				createAddDiv("Riders VP", '<img src="assets/media/rider.png">', "riders");
				// Other VPs
				createAddDiv("Other VPs", '<img src="assets/media/othervp.png">', "other");

				function createAddDiv(title, picture, idPrefix) {

					var el_VPWrapper = document.createElement("div");
						el_VPWrapper.style = "display: inline-block; vertical-align: top;"

						var el_VPPicture = document.createElement("div");
							el_VPPicture.title = title;
							el_VPPicture.className = "addScore";
							el_VPPicture.innerHTML = picture;
						el_VPWrapper.appendChild(el_VPPicture);

							var el_TokensWrapper = document.createElement("div");
								el_TokensWrapper.className = "objTokensWrapper"

							for (var i = 0; i < players.length; i++) { // Iterate players

								switch (idPrefix) {
									case "imperial": var vpHtml = players[i].vp_imperial; break;
									case "secrets": var vpHtml = players[i].vp_secrets; break;
									case "riders": var vpHtml = players[i].vp_riders; break;
									case "other": var vpHtml = players[i].vp_other; break;
								}

								var el_TokensAndPoints = document.createElement("div");

								var el_ScoreToken = document.createElement("div");
									el_ScoreToken.className = 'objTokens scored';
									el_ScoreToken.style = 'float: left;';
									el_ScoreToken.title = decodeURIComponent(players[i].player);
									el_ScoreToken.id = idPrefix + "_" + i;
									el_ScoreToken.innerHTML = '<img src="assets/media/factions/' + players[i].faction + '.png">';
									el_ScoreToken.onclick = function(event) {
										if (superuser) {
											var playerID = this.id.substring(this.id.length - 1, this.id.length);
											var category = this.id.substring(0, this.id.length - 2);
											vpPressed = { "player": playerID, "category": category };
											document.getElementById('changeVPWrapper').style.visibility = 'visible';
											noBubbling(event);
										} else {
											notSuperuser();
										}
									}
								el_TokensAndPoints.appendChild(el_ScoreToken);

								var el_Score = document.createElement("div");
									el_Score.className = 'objTokensScore';
									el_Score.innerHTML = vpHtml;
								el_TokensAndPoints.appendChild(el_Score);
								el_TokensWrapper.appendChild(el_TokensAndPoints);
							}
							el_VPWrapper.appendChild(el_TokensWrapper);
					addEldiv.appendChild(el_VPWrapper);
				}
			}
			
			newCard(allObjectives);

					if (autorefresh) {
			console.log('🔄 CLIENT: STARTING AUTO-REFRESH with', refreshCounter, 'second countdown');
			document.getElementById("sideMenuRefresh").innerHTML = refreshCounter;
			autorefreshInterval = setInterval(refreshPage, 1000);
		} else {
			console.log('✅ CLIENT: Auto-refresh disabled, no timer set');
			document.getElementById("sideMenuRefresh").innerHTML = "";
		}
		
		}).fail(function(jqXHR, textStatus, errorThrown) {
			console.error("❌ CLIENT: Failed to load data.json!");
			console.error("📊 CLIENT: Status:", textStatus);
			console.error("🐛 CLIENT: Error:", errorThrown);
			console.error("🌐 CLIENT: URL attempted:", "data.json" + jsonBuster);
			console.error("📄 CLIENT: Response:", jqXHR.responseText);
		});
			
    }

	function refreshPage() {
		refreshCounter--;
		if (refreshCounter < 0) {
			console.log('🔄 CLIENT: AUTO-REFRESH TRIGGERED - Updating data via Socket.IO');
			// Instead of reloading, request fresh data and update the view
			refreshGameData();
			refreshCounter = 30; // Reset counter
		} else {
			document.getElementById("sideMenuRefresh").innerHTML = refreshCounter;
		}
	}
	
	// Function to refresh game data without page reload
	function refreshGameData() {
		console.log('📊 CLIENT: Refreshing game data...');
		
		// Generate new cache buster
		var jsonBuster = "?v=" + Math.floor((Math.random() * 9) + 1) + Math.floor((Math.random() * 9) + 1) + "." + Math.floor((Math.random() * 9) + 1) + Math.floor((Math.random() * 9) + 1) + "." + Math.floor((Math.random() * 9) + 1) + Math.floor((Math.random() * 9) + 1);
		
		// Reload data.json and update the interface
		$.getJSON("data.json" + jsonBuster, function(data) {
			console.log('✅ CLIENT: Game data refreshed successfully');
			updateGameInterface(data);
		}).fail(function(jqXHR, textStatus, errorThrown) {
			console.error('❌ CLIENT: Failed to refresh game data:', errorThrown);
		});
	}
	
	// Function to update the game interface with new data
	function updateGameInterface(data) {
		console.log('🎮 CLIENT: Updating game interface with fresh data');
		
		// Clear existing objectives and additional elements
		var objectives1 = document.getElementById("objectives1");
		var objectives2 = document.getElementById("objectives2");
		var additionalElements = document.getElementById("additionalElementsWrapper");
		
		if (objectives1) objectives1.innerHTML = '';
		if (objectives2) objectives2.innerHTML = '';
		if (additionalElements) additionalElements.remove();
		
		// Reset global state arrays
		objectivesOnBoard = { stage1: [], stage2: [] };
		allPlayers = [];
		allScores = [];
		
		// Load objectives first, then update interface
		loadObjectivesAndUpdateInterface(data);
	}
	
	// Function to load objectives and then update interface
	function loadObjectivesAndUpdateInterface(data) {
		console.log('📊 CLIENT: Loading objectives for interface update...');
		
		// Clear existing objectives arrays first
		allObjectives = [];
		stageOneObjectives = [];
		stageTwoObjectives = [];
		secretObjectives = [];
		
		var jsonBuster = "?v=" + Math.floor((Math.random() * 9) + 1) + Math.floor((Math.random() * 9) + 1) + "." + Math.floor((Math.random() * 9) + 1) + Math.floor((Math.random() * 9) + 1) + "." + Math.floor((Math.random() * 9) + 1) + Math.floor((Math.random() * 9) + 1);
		
		// Check if community cards are enabled and load them if needed
		if (data[3] && data[3].communitycards) {
			console.log('🎮 CLIENT: Community cards enabled, loading for refresh...');
			
			$.getJSON("database.json" + jsonBuster, function(mainObjectives) {
				console.log('✅ CLIENT: Main database loaded for refresh!');
				
				// Load main objectives
				for (var i = 0; i < mainObjectives[0].stage1.length; i++) {
					allObjectives.push(mainObjectives[0].stage1[i]);
					stageOneObjectives.push(mainObjectives[0].stage1[i]);
				}
				for (var i = 0; i < mainObjectives[0].stage2.length; i++) {
					allObjectives.push(mainObjectives[0].stage2[i]);
					stageTwoObjectives.push(mainObjectives[0].stage2[i]);
				}
				
				$.getJSON("database_community.json" + jsonBuster, function(communityObjectives) {
					console.log('✅ CLIENT: Community database loaded for refresh!');
					
					// Load community objectives
					for (var i = 0; i < communityObjectives[0].stage1.length; i++) {
						allObjectives.push(communityObjectives[0].stage1[i]);
						stageOneObjectives.push(communityObjectives[0].stage1[i]);
					}
					for (var i = 0; i < communityObjectives[0].stage2.length; i++) {
						allObjectives.push(communityObjectives[0].stage2[i]);
						stageTwoObjectives.push(communityObjectives[0].stage2[i]);
					}
					for (var i = 0; i < communityObjectives[0].secret.length; i++) {
						allObjectives.push(communityObjectives[0].secret[i]);
						secretObjectives.push(communityObjectives[0].secret[i]);
					}
					
					console.log('📊 CLIENT: Total objectives loaded for refresh:', allObjectives.length);
					
					// Now update the interface with all cards loaded
					updateGameInterfaceWithCards(data);
				}).fail(function(jqXHR, textStatus, errorThrown) {
					console.error('❌ CLIENT: Failed to load community database for refresh:', errorThrown);
					updateGameInterfaceWithCards(data);
				});
			}).fail(function(jqXHR, textStatus, errorThrown) {
				console.error('❌ CLIENT: Failed to load main database for refresh:', errorThrown);
				updateGameInterfaceWithCards(data);
			});
		} else {
			console.log('ℹ️ CLIENT: Community cards disabled, loading only main database for refresh');
			
			$.getJSON("database.json" + jsonBuster, function(mainObjectives) {
				console.log('✅ CLIENT: Main database loaded for refresh!');
				
				// Load main objectives only
				for (var i = 0; i < mainObjectives[0].stage1.length; i++) {
					allObjectives.push(mainObjectives[0].stage1[i]);
					stageOneObjectives.push(mainObjectives[0].stage1[i]);
				}
				for (var i = 0; i < mainObjectives[0].stage2.length; i++) {
					allObjectives.push(mainObjectives[0].stage2[i]);
					stageTwoObjectives.push(mainObjectives[0].stage2[i]);
				}
				
				console.log('📊 CLIENT: Total objectives loaded for refresh:', allObjectives.length);
				updateGameInterfaceWithCards(data);
			}).fail(function(jqXHR, textStatus, errorThrown) {
				console.error('❌ CLIENT: Failed to load main database for refresh:', errorThrown);
				updateGameInterfaceWithCards(data);
			});
		}
	}
	
			// Function to update the game interface with cards already loaded
		function updateGameInterfaceWithCards(data) {
			try {
				// Rebuild players array
				var players = [];
				var playerScores = [];
				for (var i = 0; i < data[2].players.length; i++) {
					if (data[2].players[i].faction != null) {
						var playah = data[2].players[i];
						allPlayers.push(playah);
						allScores.push(0);
						players.push(playah);
						playerScores.push(0); // Initialize to 0, will be calculated from objectives
					}
				}
				
				// Calculate scores from objectives
				calculateScoresFromObjectives(data, playerScores);
			
			// Recreate objectives for both stages if they exist
			if (data[0] && data[0].cards && data[0].cards.length > 0) {
				console.log('🎮 CLIENT: Rebuilding Stage 1 objectives...');
				createObjectivesForUpdate(1, data, players);
			}
			
			if (data[1] && data[1].cards && data[1].cards.length > 0) {
				console.log('🎮 CLIENT: Rebuilding Stage 2 objectives...');
				createObjectivesForUpdate(2, data, players);
			}
			
			// Recreate scoreboard
			createScoreboard(players, playerScores);
			
			// Recreate additional elements if there are players
			if (players.length > 0) {
				console.log('🎮 CLIENT: Rebuilding additional elements...');
				createAdditionalPointsForUpdate(players, data);
				
				// Restore Additional Scores menu state if it was open
				if (additionalScoresMenuOpen) {
					setTimeout(function() {
						$("#additionalElementsWrapper").addClass("open");
						$("#additionalElementsArrowLeft").addClass("open");
						$("#additionalElementsArrowRight").addClass("open");
						console.log('📊 CLIENT: Restored Additional Scores menu to open state');
					}, 50); // Small delay to ensure elements are created
				}
			}
			
			console.log('✅ CLIENT: Interface rebuilt successfully with fresh data');
			
			// Start timer if not already running
			if (!gameTimer) {
				gameTimer = setInterval(updateTimer, 1000);
				console.log('⏰ CLIENT: Game timer started');
			}
			
			// Show bigletter for the last flipped card if available
			if (window.lastFlippedCardID) {
				console.log('🎯 CLIENT: Showing bigletter for last flipped card:', window.lastFlippedCardID);
				setTimeout(function() {
					showCardInBigletter(window.lastFlippedCardID);
					window.lastFlippedCardID = null; // Clear after showing
				}, 100); // Small delay to ensure interface is fully rendered
			}
		} catch(err) {
			console.error('❌ CLIENT: Error rebuilding interface:', err);
		}
		
		// Emit update event to other clients via Socket.IO
		if (socket && socket.connected) {
			socket.emit('interface_refresh', { timestamp: Date.now() });
			console.log('📡 CLIENT: Notified other clients of interface update');
		}
	}
	
	// Helper function to create objectives during update (same logic as createObjectives)
	function createObjectivesForUpdate(stage, data, players) {
		var stageIndex = stage - 1;
		var objectivesCount = data[stageIndex].cards.length;
		var activeCardIndex = 0;
		
		for (var i = 0; i < objectivesCount; i++) {
			var cardID = data[stageIndex].cards[i].id;
			if (stage == 1) {
				objectivesOnBoard.stage1.push(data[stageIndex].cards[i]);
			} else {
				objectivesOnBoard.stage2.push(data[stageIndex].cards[i]);
			}
			
			if (cardID != null) {
				// Find card info in allObjectives
				for (var k = 0; k < allObjectives.length; k++) {
					if (cardID == allObjectives[k].id) {
						var cardName = allObjectives[k].name;
						var cardText = allObjectives[k].text;
						var cardPoints = allObjectives[k].points;
						var cardStage = allObjectives[k].stage;
						var cardPhase = allObjectives[k].phase;
						var phaseColor = "";
						if (cardPhase == "Action Phase") phaseColor = "red";

						// Create elements
						var objectiveDiv = document.getElementById("objectives" + stage);
						
						var el_TokensAndCard = document.createElement("div");
						el_TokensAndCard.className = "tokensAndCard";
						objectiveDiv.appendChild(el_TokensAndCard);

						var el_Objective = document.createElement("div");
						el_Objective.className = 'objContainer';
						el_Objective.id = i;
						el_Objective.innerHTML = "<img src='assets/media/objectivecard_bg_" + cardStage + ".png'>";
						el_TokensAndCard.appendChild(el_Objective);

						var el_ObjectiveText = document.createElement("div");
						el_ObjectiveText.className = 'objCard';
						el_ObjectiveText.id = cardID;
						el_ObjectiveText.innerHTML = "<h2>" + escapeHtml(cardName) + "</h2><p>" + escapeHtml(cardText) + "</p><h3>" + escapeHtml(cardPoints) + "</h3><p style='margin-top:-1.5vw' class='" + escapeHtml(phaseColor) + "'>" + escapeHtml(cardPhase) + "</p></div>";
						
						// Add click handler (simplified version for updates)
						el_ObjectiveText.onclick = function() {
							var cardPressedIndex = parseInt(this.parentNode.id);
							stagePressed = this.parentNode.parentNode.parentNode.id;
							stagePressed = stagePressed.substring(stagePressed.length - 1, stagePressed.length);
							
							// Always set cardPressed to the card slot identifier for consistency
							cardPressed = "stage" + stagePressed + "_" + cardPressedIndex;
							
							if (clickMode != null) {
								if (clickMode == "hide" || clickMode == "remove") {
									if (confirm("Are you sure you want to " + clickMode + " this card?\nThe points will be reset for this card.")) {
										var adjustData = [clickMode, stagePressed, this.id, cardPressedIndex];
										console.log('📡 CLIENT: Emitting card adjustment:', adjustData);
										socket.emit('adjust' + clickMode.charAt(0).toUpperCase() + clickMode.slice(1), adjustData);
									}
								} else {
									document.getElementById('objectiveStyleWrapper').style.visibility = 'visible';
									event.stopPropagation();
								}
							} else {
								// Show card details logic would go here
								console.log('📊 CLIENT: Card selected for details:', cardPressed);
							}
						};
						el_Objective.appendChild(el_ObjectiveText);

						// Create token wrapper and tokens
						var el_TokensWrapper = document.createElement("div");
						el_TokensWrapper.className = "objTokensWrapper";
						el_TokensWrapper.id = activeCardIndex;

						for (var j = 0; j < players.length; j++) {
							var el_Token = document.createElement("div");
							
							// Use correct CSS classes for scored/unscored tokens
							if (data[stageIndex].cards[i].scores[j].scored) {
								el_Token.className = "objTokens scored";
							} else {
								el_Token.className = "objTokens";
							}
							
							el_Token.title = decodeURIComponent(players[j].player);
							el_Token.id = j; // Simple player ID like in original
							el_Token.innerHTML = '<img src="assets/media/factions/' + players[j].faction + '.png">';
							
							// Add click handler for token scoring (matching original logic)
							(function(cardIndex) {
								el_Token.onclick = function(event) {
									if (superuser) {
										var tokenPressed = this.id;
										var stagePressed = stage;
										var cardPressed = cardIndex;
										
										// Direct Socket.IO emission for token scoring
										var tokenData = [stagePressed - 1, cardPressed, tokenPressed]; // stageIndex, cardIndex, playerIndex
										console.log('📡 CLIENT: Emitting token scoring:', tokenData);
										socket.emit('token', tokenData);
									} else {
										notSuperuser();
									}
									noBubbling(event);
								};
							})(activeCardIndex);
							
							el_TokensWrapper.appendChild(el_Token);
						}
						el_TokensAndCard.appendChild(el_TokensWrapper);
						break;
					}
				}
			} else {
				// Handle null card IDs - create empty card slots (same as original createObjectives)
				var tokensHTML = "";
				for (var j = 0; j < players.length; j++) {
					if (players[j].faction == null) {
						var token = "empty"
					} else {
						var token = players[j].faction;
					}
					tokensHTML = tokensHTML + '<div class="objTokens" title="' + decodeURIComponent(players[j].player) + '"><img src="assets/media/factions/' + token + '.png"></div>';
				}
				
				// Create elements
				var objectiveDiv = document.getElementById("objectives" + stage);

				var el_TokensAndCard = document.createElement("div");
				el_TokensAndCard.className = "tokensAndCard";
				el_TokensAndCard.id = i;
				objectiveDiv.appendChild(el_TokensAndCard);

				var el_Objective = document.createElement("div");
				el_Objective.className = 'objContainer';
				el_Objective.innerHTML = "<img src='assets/media/backside_stage" + stage + ".png'>";
				el_Objective.id = "stage" + stage + "_" + i;
				el_Objective.onclick = function(event) {
					if (superuser) {
						cardPressed = this.id;
						stagePressed = this.parentNode.parentNode.id;
						stagePressed = stagePressed.substring(stagePressed.length - 1, stagePressed.length);
						var cardPressedIndex = parseInt(this.parentNode.id);
						if (clickMode == "remove") {
							if (confirm("Are you sure you want to remove this card?")) {
								// Direct Socket.IO emission for card removal
								var adjustData = [clickMode, stagePressed, cardPressed, cardPressedIndex];
								console.log('📡 CLIENT: Emitting card removal:', adjustData);
								socket.emit('adjustRemove', adjustData);
							}
						} else {
							document.getElementById('objectiveStyleWrapper').style.visibility = 'visible';
							event.stopPropagation();
						}
					} else {
						notSuperuser();
					}
				};
				el_TokensAndCard.appendChild(el_Objective);

				var el_TokensWrapper = document.createElement("div");
				el_TokensWrapper.className = "objTokensWrapper";
				el_TokensWrapper.innerHTML = tokensHTML;
				el_TokensAndCard.appendChild(el_TokensWrapper);
			}
			activeCardIndex++;
		}
	}
	
	// Helper function to create additional points section during update
	function createAdditionalPointsForUpdate(players, data) {
		var el_AddWrapperDiv = document.createElement("div");
		el_AddWrapperDiv.id = "additionalElementsWrapper";
		el_AddWrapperDiv.onclick = function() {
			$("#additionalElementsWrapper").toggleClass("open");
			$("#additionalElementsArrowLeft").toggleClass("open");
			$("#additionalElementsArrowRight").toggleClass("open");
		}
		document.getElementById("wrapper").appendChild(el_AddWrapperDiv);
		
		var el_AddTextArrowWrapperDiv = document.createElement("div");
		el_AddTextArrowWrapperDiv.className = "additionalElementsTextArrowWrapper";
		el_AddWrapperDiv.appendChild(el_AddTextArrowWrapperDiv);
		
		var el_AddArrowDiv = document.createElement("div");
		el_AddArrowDiv.id = "additionalElementsArrowLeft";
		el_AddArrowDiv.innerHTML = "<img src='assets/media/arrow_white.png'>";
		el_AddTextArrowWrapperDiv.appendChild(el_AddArrowDiv);
		
		var el_AddButtonDiv = document.createElement("div");
		el_AddButtonDiv.className = "additionalElementsText";
		el_AddButtonDiv.innerHTML = "Additional Scores";
		el_AddTextArrowWrapperDiv.appendChild(el_AddButtonDiv);
		
		var el_AddArrowDiv2 = document.createElement("div");
		el_AddArrowDiv2.id = "additionalElementsArrowRight";
		el_AddArrowDiv2.innerHTML = "<img src='assets/media/arrow_white.png'>";
		el_AddTextArrowWrapperDiv.appendChild(el_AddArrowDiv2);
		
		var el_AddDiv = document.createElement("div");
		el_AddDiv.id = "additionalElements";
		el_AddWrapperDiv.appendChild(el_AddDiv);
		
		// Create additional points elements with proper implementation
		createAdditionalPointsComplete(players, data);
	}
	
	// Complete implementation of additional points creation
	function createAdditionalPointsComplete(players, data) {
		var addEldiv = document.getElementById("additionalElements");

		// Mecatol VP
		var custodianHtml = "";
		for (var i = 0; i < players.length; i++) { // Iterate players
			if (players[i].vp_custodian) custodianHtml = '<img src="assets/media/factions/' + players[i].faction + '.png">';
		}
		var el_MecatolWrapper = document.createElement("div");
		el_MecatolWrapper.id = "mecatolScoreWrapper";
		el_MecatolWrapper.style = "display: inline-block; vertical-align: top;"

		var el_Mecatol = document.createElement("div");
		el_Mecatol.title = "Custodian Token VP";
		el_Mecatol.id = "mecatolScore";
		el_Mecatol.innerHTML = custodianHtml;
		el_Mecatol.onclick = function(event) {
			if (superuser) {
				var wrapper = document.getElementById('changeCustodianWrapper');
				wrapper.innerHTML = "Custodian Victory Point<br><br>";
				for (var i = 0; i < players.length; i++) { // Iterate players
					var el_Token = document.createElement("div");
					el_Token.className = 'custodianPick';
					el_Token.title = decodeURIComponent(players[i].player);
					el_Token.id = "custodian_" + i;
					el_Token.innerHTML = '<img src="assets/media/factions/' + players[i].faction + '.png">';
					el_Token.onclick = function(event) {
						var playerID = this.id.substring(this.id.length - 1, this.id.length);
						vpPressed = { "player": playerID, "category": "custodian" };
						// Direct Socket.IO emission for custodian VP change
						var vpData = [playerID, "custodian"];
						console.log('📡 CLIENT: Emitting custodian VP change for player:', playerID);
						socket.emit('changeVP', vpData);
						// Close the custodian menu after selection
						document.getElementById('changeCustodianWrapper').style.visibility = 'hidden';
						noBubbling(event);
					}
					wrapper.appendChild(el_Token);
				}
				document.getElementById('changeCustodianWrapper').style.visibility = 'visible';
				noBubbling(event);
			} else {
				notSuperuser();
			}
		}
		el_MecatolWrapper.appendChild(el_Mecatol);
		addEldiv.appendChild(el_MecatolWrapper);

		// Imperial VP
		createAddDivForUpdate("Imperial VP", '<img src="assets/media/imperial.png">', "imperial", players, addEldiv);
		// Secrets VP
		createAddDivForUpdate("Secrets VP", '<img src="assets/media/backside_secret.png">', "secrets", players, addEldiv);
		// Rider VP
		createAddDivForUpdate("Riders VP", '<img src="assets/media/rider.png">', "riders", players, addEldiv);
		// Other VPs
		createAddDivForUpdate("Other VPs", '<img src="assets/media/othervp.png">', "other", players, addEldiv);
	}
	
	// Helper function to create additional VP divs
	function createAddDivForUpdate(title, picture, idPrefix, players, addEldiv) {
		var el_VPWrapper = document.createElement("div");
		el_VPWrapper.style = "display: inline-block; vertical-align: top;"

		var el_VPPicture = document.createElement("div");
		el_VPPicture.title = title;
		el_VPPicture.className = "addScore";
		el_VPPicture.innerHTML = picture;
		el_VPWrapper.appendChild(el_VPPicture);

		var el_TokensWrapper = document.createElement("div");
		el_TokensWrapper.className = "objTokensWrapper"

		for (var i = 0; i < players.length; i++) { // Iterate players
			switch (idPrefix) {
				case "imperial": var vpHtml = players[i].vp_imperial; break;
				case "secrets": var vpHtml = players[i].vp_secrets; break;
				case "riders": var vpHtml = players[i].vp_riders; break;
				case "other": var vpHtml = players[i].vp_other; break;
			}

			var el_TokensAndPoints = document.createElement("div");

			var el_ScoreToken = document.createElement("div");
			el_ScoreToken.className = 'objTokens scored';
			el_ScoreToken.style = 'float: left;';
			el_ScoreToken.title = decodeURIComponent(players[i].player);
			el_ScoreToken.id = idPrefix + "_" + i;
			el_ScoreToken.innerHTML = '<img src="assets/media/factions/' + players[i].faction + '.png">';
			el_ScoreToken.onclick = function(event) {
				if (superuser) {
					var playerID = this.id.substring(this.id.length - 1, this.id.length);
					var category = this.id.substring(0, this.id.length - 2);
					vpPressed = { "player": playerID, "category": category };
					document.getElementById('changeVPWrapper').style.visibility = 'visible';
					noBubbling(event);
				} else {
					notSuperuser();
				}
			}
			el_TokensAndPoints.appendChild(el_ScoreToken);

			var el_Score = document.createElement("div");
			el_Score.className = 'objTokensScore';
			el_Score.innerHTML = vpHtml;
			el_TokensAndPoints.appendChild(el_Score);
			el_TokensWrapper.appendChild(el_TokensAndPoints);
		}
		el_VPWrapper.appendChild(el_TokensWrapper);
		addEldiv.appendChild(el_VPWrapper);
	}

	function bigletterHide() {
		document.getElementById('bigletter').style.visibility = 'hidden';
	}

	function showMenu(event) {
		document.getElementById('warnTop').style.visibility = 'hidden';
		document.getElementById('warnBottom').style.visibility = 'hidden';
		document.getElementById('warnLeft').style.visibility = 'hidden';
		document.getElementById('warnRight').style.visibility = 'hidden';
		document.getElementById('sideMenuBg').style.visibility = 'visible';
		document.getElementById('sideMenu').classList.add("show");
		event.stopPropagation();
	}

	function objectiveCategory(event, category) {
		$('#objectiveList').html("");
		switch (category) {
			case ("stage1"): var objArray = stageOneObjectives; break;
			case ("stage2"): var objArray = stageTwoObjectives; break;
			case ("secret"): var objArray = secretObjectives; break;
		}
		for (var i = 0; i < objArray.length; i++) {
			var objId = objArray[i].id;
			var el_ListItem = document.createElement("div");
				el_ListItem.className = "objectiveListItem";
				el_ListItem.innerHTML = objArray[i].name;
						el_ListItem.id = objArray[i].id;
		el_ListItem.onclick = function() {
			// Direct Socket.IO emission instead of page redirect
			var cardData = [cardPressed, this.id, "normal"];
			console.log('📡 CLIENT: Emitting card selection:', cardData);
			socket.emit('update', cardData);
		}
	document.getElementById('objectiveList').appendChild(el_ListItem);
		}
		event.stopPropagation();
	}

	function noBubbling(event) {
		event.stopPropagation();
	}

	function closeMenu() {
		clickMode = null;
		document.getElementById('editScoreWrapper').style.visibility = 'hidden';
		document.getElementById('addCardWrapper').style.visibility = 'hidden';
		document.getElementById('newGameWrapper').style.visibility = 'hidden';
		document.getElementById('warnTop').style.visibility = 'hidden';
		document.getElementById('warnBottom').style.visibility = 'hidden';
		document.getElementById('warnLeft').style.visibility = 'hidden';
		document.getElementById('warnRight').style.visibility = 'hidden';
		document.getElementById('adjustCardWrapper').style.visibility = 'hidden';
		document.getElementById('objectiveStyleWrapper').style.visibility = 'hidden';
		document.getElementById('changeVPWrapper').style.visibility = 'hidden';
		document.getElementById('changeCustodianWrapper').style.visibility = 'hidden';
		document.getElementById('objectiveMenuWrapper').style.visibility = 'hidden';
		document.getElementById('objectiveMenu').style.visibility = 'hidden';
		document.getElementById('objectiveList').style.visibility = 'hidden';
		document.getElementById('sideMenuBg').style.visibility = 'hidden';
		document.getElementById('sideMenu').classList.remove("show");
    }
    
    function getUrlVars() {
        var vars = {};
        var parts = window.location.href.replace(/[?&]+([^=&]+)=([^&]*)/gi, function(m,key,value) {
            vars[key] = value;
        });
        return vars;
	}
	
	function getCardInfo(id) {
		console.log('🔍 CLIENT: getCardInfo called with id:', id);
		console.log('🔍 CLIENT: allObjectives length:', allObjectives.length);
		var theObj = null;
		for (var allCardIndex = 0; allCardIndex < allObjectives.length; allCardIndex++) {
			if (id == allObjectives[allCardIndex].id) {
				theObj = allObjectives[allCardIndex];
				console.log('✅ CLIENT: Found card info:', theObj);
				break;
			}
		}
		if (!theObj) {
			console.error('❌ CLIENT: Card info not found for id:', id);
			console.log('🔍 CLIENT: Available card IDs:', allObjectives.map(obj => obj.id));
		}
		return theObj;
	}

	function newCard(arr) {
		var newId = getUrlVars()["id"];
		for (var i = 0; i < arr.length; i++) {
			if (arr[i].id == newId) {

				window.history.replaceState({}, document.title, "/tvajlajt");
				
				var cardItem = arr[i];
				var blTokensHtml = "";
				
				var cardPhase = cardItem.phase;
				var phaseColor = "";
				if (cardPhase == "Action Phase") phaseColor = "red";
				var html = 	'<div class="blPlayers">' + blTokensHtml + '</div>'+
							'<div class="blTitle">' + cardItem.name + '</div>'+
							'<div class="blText">' + cardItem.text + '</div>'+
							'<div class="blPhaseAndPoints">'+
								'<div class="blPhase ' + phaseColor + '">' + cardPhase.substring(0, cardPhase.indexOf(" ")) + '</div>'+
								'<div class="blPoint">' + cardItem.points + '</div>'+
								'<div class="blPhase ' + phaseColor + '">' + cardPhase.substring(cardPhase.indexOf(" ") + 1, cardPhase.length) + '</div>'+
							'</div>';
				$('#bigletter').html(html);
				document.getElementById('bigletter').style.visibility = 'visible';

				break;
			}
		}
	}

	function chooseCard(event, style) {

		document.getElementById('objectiveStyleWrapper').style.visibility = 'hidden';
		
		if (style == "random") {

			var illegalObjectives = [];
			for (var i = 0; i < objectivesOnBoard.stage1.length; i++) {
				if (objectivesOnBoard.stage1[i].id != null) illegalObjectives.push(objectivesOnBoard.stage1[i].id);
			}
			for (var i = 0; i < objectivesOnBoard.stage2.length; i++) {
				if (objectivesOnBoard.stage2[i].id != null) illegalObjectives.push(objectivesOnBoard.stage2[i].id);
			}

			if (stagePressed == 1) {
				var objArray = stageOneObjectives;
			} else {
				var objArray = stageTwoObjectives;
			}

			var randomCard = Math.floor((Math.random() * (objArray.length - 1)) + 1);
			while (illegalObjectives.includes(objArray[randomCard].id)) {
				randomCard = Math.floor((Math.random() * objArray.length - 1) + 1);
			}

					var mode = "new";
		if (clickMode != null) mode = "change";
		// Direct Socket.IO emission for random card assignment
		var cardData = [cardPressed, objArray[randomCard].id, mode];
		console.log('📡 CLIENT: Emitting random card assignment:', cardData);
		socket.emit('update', cardData);

		} else {
			$('#objectiveList').html("");
			if (stagePressed == 1) {
				var objArray = stageOneObjectives;
			} else {
				var objArray = stageTwoObjectives;
			}
			for (var j = 0; j < objArray.length; j++) {
				var objId = objArray[j].id;
				var el_ListItem = document.createElement("div");
					el_ListItem.className = "objectiveListItem";
					el_ListItem.innerHTML = objArray[j].name;
									el_ListItem.id = objArray[j].id;
				el_ListItem.onclick = function() {
					// Direct Socket.IO emission instead of page redirect
					var cardData = [cardPressed, this.id, "normal"];
					console.log('📡 CLIENT: Emitting card selection (community):', cardData);
					socket.emit('update', cardData);
				}
			document.getElementById('objectiveList').appendChild(el_ListItem);
			}
			document.getElementById('objectiveMenuWrapper').style.visibility = 'visible';
			document.getElementById('objectiveMenu').style.visibility = 'visible';
			document.getElementById('objectiveList').style.visibility = 'visible';
		}
		event.stopPropagation();

	}

	function adjustCard(event, adjustment) {
		clickMode = adjustment;
		document.getElementById('adjustCardWrapper').style.visibility = 'hidden';
		document.getElementById('warnTop').style.visibility = 'visible';
		document.getElementById('warnBottom').style.visibility = 'visible';
		document.getElementById('warnLeft').style.visibility = 'visible';
		document.getElementById('warnRight').style.visibility = 'visible';
		event.stopPropagation();
	}

	function addCard(event, stage) {
		// Direct Socket.IO emission for adding cards
		console.log('📡 CLIENT: Emitting add card for stage:', stage);
		socket.emit('addCard', stage);
		closeMenu(); // Close the menu after action
	}

	function submitNewGame(event) {
		event.preventDefault(); // Prevent default form submission
		
		console.log('🎮 CLIENT: Collecting new game data...');
		
		// Get form data
		var form = document.getElementById('newGameForm');
		var formData = new FormData(form);
		
		// Extract flipped objectives setting
		var flippedObjectives = formData.get('flippedobjectives') || '3';
		
		// Extract starting cards setting
		var startingCards = formData.get('startingcards') || '5';
		
		// Extract community cards setting
		var communityCards = formData.get('communitycards_hidden') === 'true';
		console.log('🔍 CLIENT: Raw community cards value:', formData.get('communitycards_hidden'));
		console.log('🔍 CLIENT: Processed community cards value:', communityCards);
		
		// Extract players data
		var players = [];
		for (var i = 1; i <= 8; i++) {
			var playerName = formData.get('player' + i + '_name');
			var playerFaction = formData.get('player' + i + '_faction');
			var playerColor = formData.get('player' + i + '_color');
			
			if (playerName && playerName.trim() !== '' && playerFaction && playerFaction !== 'none') {
				players.push({
					name: playerName.trim(),
					faction: playerFaction,
					color: playerColor || 'red'
				});
				console.log('👤 CLIENT: Added player:', playerName, '-', playerFaction);
			}
		}
		
		// Prepare data for server (matching expected format)
		var newGameData = [startingCards, players, communityCards, flippedObjectives];
		
		console.log('🎮 CLIENT: Starting new game with data:', newGameData);
		console.log('📊 CLIENT: Settings - Cards:', startingCards, 'Community:', communityCards, 'Players:', players.length);
		
		// Emit new game data via Socket.IO
		socket.emit('newgame', newGameData);
		
		// Close the new game menu
		closeMenu();
		
		return false; // Prevent form submission
	}

	function changeVP(event, adjustment) {
		if (adjustment == "+") {
			adjustment = "up";
		} else {
			adjustment = "down";
		}
		// Direct Socket.IO emission for VP adjustment
		var vpData = [vpPressed.player, vpPressed.category, adjustment];
		console.log('📡 CLIENT: Emitting VP adjustment:', vpData);
		socket.emit('changeVP', vpData);
	}

	function buttonClick(event, id) {
		if (id == "btnReset" && superuser) {
			closeMenu();
			if (confirm("Are you sure you want to reset?\nThis will hide all cards, zero all points and remove all players.")) {
				// Direct Socket.IO emission for game reset
				console.log('📡 CLIENT: Emitting game reset');
				socket.emit('reset', {});
			}

		} else if (id == "btnNew" && superuser) {
			closeMenu();
			
			// Check if there's already a game in progress
			var hasActiveGame = false;
			if (allPlayers && allPlayers.length > 0) {
				hasActiveGame = true;
			}
			
			if (hasActiveGame) {
				if (confirm("A game is already in progress. Starting a new game will clear the current game and all progress. Are you sure you want to continue?")) {
					document.getElementById('newGameWrapper').style.visibility = 'visible';
				}
			} else {
				document.getElementById('newGameWrapper').style.visibility = 'visible';
			}
		} else if (id == "btnAddcard" && superuser) {
			closeMenu();
			document.getElementById('addCardWrapper').style.visibility = 'visible';
		} else if (id == "btnAdjustcard" && superuser) {
			closeMenu();
			document.getElementById('adjustCardWrapper').style.visibility = 'visible';
		} else if (id == "sideMenuTime" && superuser) {
			// console.log("Pause");
		} else if (id == "sideMenuRefresh") {
			if (localStorage.getItem('autorefresh') == "true") {
				clearInterval(autorefreshInterval);
				localStorage.setItem('autorefresh', "false");
			} else {
				localStorage.setItem('autorefresh', "true");
				document.getElementById("sideMenuRefresh").innerHTML = refreshCounter;
				autorefreshInterval = setInterval(refreshPage, 1000);
				// window.location.reload()
			}
		} else if (id == "btnSuperuser") {
			localStorage.setItem('superuser', String(!superuser));
			superuser = !superuser;
			var superuserHtml = (superuser) ? "y" : (!superuser) ? "n" : "";
			document.getElementById("btnSuperuser").innerHTML = '<img class="sideMenuItemIcon" src="assets/media/buttons/superuser_' + superuserHtml + '.png"><div class="sideMenuItemText">Superuser</div>';
		} else if (!superuser) {
			notSuperuser();
		}
		event.stopPropagation();
	}

	function notSuperuser() {
		var html = '<div class="blTitle"><img style="max-width:20vw" src="assets/media/buttons/superuser_n.png"></div><div class="blText">Not allowed as non-superuser</div>';
		$('#bigletter').html(html);
		document.getElementById('bigletter').style.visibility = 'visible';
		event.stopPropagation();
	}
	
</script>

</body>
</html>
